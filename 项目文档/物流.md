# 技能点

## 减少Validated冗余 AOP

**在controller上加@Validated之后就能 在参数上使用注解校验参数**

![image-20240304214446880](C:/Users/da%20zhou/AppData/Roaming/Typora/typora-user-images/image-20240304214446880.png)

**但是如果想要 使类中的注解也生效**

![image-20240304214628552](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20240304214628552.png)

需要在参数添加@Validated 这样子就会与类上的@Validated冗余

![image-20240304214700839](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20240304214700839.png)

使用aop的方式校验，不用在参数前加@Validated也可以校验，如果有问题则将异常抛出，专门写个异常处理器处理

```java
/**
 * 请求参数校验切面，统一对Controller中@RequestBody映射的对象进行校验，在Controller方法中无需单独处理
 */
@Aspect
@Slf4j
@EnableAspectJAutoProxy
@Component
public class ValidatedAspect {

    @Resource
    private Validator validator;

    @Around("execution(* com.sl..controller.*Controller.*(..))")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        // 获取@RequestBody映射的对象
        Object body = AspectUtil.getBody(proceedingJoinPoint);
        // 不为空的body进行拦截校验
        if (!ObjectUtil.isEmpty(body)) {
            // 进行校验
            Set<ConstraintViolation<Object>> validateResult = validator.validate(body);
            if (CollUtil.isNotEmpty(validateResult)) {
                //没有通过校验，抛出异常，由统一异常处理机制进行处理，响应400
                String info = JSONUtil.toJsonStr(validateResult.stream()
                        .map(ConstraintViolation::getMessage).collect(Collectors.toList()));
                throw new SLException(info, HttpStatus.BAD_REQUEST.value());
            }
        }
        //校验通过，执行原方法
        return proceedingJoinPoint.proceed(proceedingJoinPoint.getArgs());
    }

}
```





```java
/**
 * 自定义异常
 */
@Data
public class SLException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private String msg; //异常中的信息
    private int code = 1001; //业务状态码，规则：4位数，从1001开始递增
    private int status = 500; //http状态码，按照http协议规范，如：200,201,400等

    public SLException(BaseEnum baseEnum) {
        super(baseEnum.getValue());
        this.msg = baseEnum.getValue();
        this.code = baseEnum.getCode();
    }

    public SLException(BaseEnum baseEnum, Throwable e) {
        super(baseEnum.getValue(), e);
        this.msg = baseEnum.getValue();
        this.code = baseEnum.getCode();
    }

    public SLException(BaseExceptionEnum errorEnum) {
        super(errorEnum.getValue());
        this.status = errorEnum.getStatus();
        this.msg = errorEnum.getValue();
        this.code = errorEnum.getCode();
    }

    public SLException(BaseExceptionEnum errorEnum, Throwable e) {
        super(errorEnum.getValue(), e);
        this.status = errorEnum.getStatus();
        this.msg = errorEnum.getValue();
        this.code = errorEnum.getCode();
    }

    public SLException(String msg) {
        super(msg);
        this.msg = msg;
    }

    public SLException(String msg, Throwable e) {
        super(msg, e);
        this.msg = msg;
    }

    public SLException(String msg, int code) {
        super(msg);
        this.msg = msg;
        this.code = code;
    }

    public SLException(String msg, int code, int status) {
        super(msg);
        this.msg = msg;
        this.code = code;
        this.status = status;
    }

    public SLException(String msg, int code, Throwable e) {
        super(msg, e);
        this.msg = msg;
        this.code = code;
    }

    public SLException(String msg, int code, int status, Throwable e) {
        super(msg, e);
        this.msg = msg;
        this.code = code;
        this.status = status;
    }

}
```



```java
    /**
     * web自定义异常处理
     * 用于统一封装VO对象返回前端
     *
     * @param exception web自定义异常
     * @return 响应数据
     */
    @ExceptionHandler(SLWebException.class)
    public ResponseEntity<Object> handle(SLWebException exception) {
        if (ObjectUtil.isNotEmpty(exception.getCause())) {
            log.error("自定义异常处理 -> ", exception);
        }
        JSONObject jsonObject = JSONUtil.parseObj(exception);
        return ResponseEntity.ok(MapUtil.<String, Object>builder()
                .put("code", exception.getCode())
                .put("msg", jsonObject.getStr("msg"))
                .build());
    }
```





## 使用责任链模式解决查找运费模板问题

### 需求

​	计算运费，不同的运费模板有不同的价格，在计算运费前要先判断此次寄件属于那个模板。

可以按照责任链的方法来判断是属于那个模板,在判断时会根据我们设置的handler顺序来判断寄件属于那个模板。

![image-20240305155008044](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20240305155008044.png)

### 实现

首先定义一个抽象类，在类中需要有处理当前链的方法，下一个链中要做的方法，设置下一个链的方法

```java
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 10:25
 */
public abstract class AbstractCarriageChainHandler {
    
    private AbstractCarriageChainHandler nextHandler;

    /**
     * 执⾏过滤⽅法，通过输⼊参数查找运费模板
     * @param waybillDTO 输⼊参数
     * @return 运费模板
     */
    public abstract CarriageEntity doHandler(WaybillDTO waybillDTO);


    protected CarriageEntity doNextHandler(WaybillDTO waybillDTO,CarriageEntity carriageEntity){
        if (nextHandler==null || carriageEntity!=null){
            //如果下游的Handler为空 或上个Handler已经找到运费模板就返回
            return carriageEntity;
        }
        return nextHandler.doHandler(waybillDTO);
    }

    /**
     * 设置下游Handler
     * @param nextHandler 下游Handler
     */
    public void setNextHandler(AbstractCarriageChainHandler nextHandler){
        this.nextHandler=nextHandler;
    }
}
```

具体实现的类，在具体的实现中重写doHandler，在该方法中执行该链中的逻辑.

同城寄

```java
/**
 * 同城寄
 *
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 14:30
 */
@Order(100)
@Component
public class SameCityChainHandler extends AbstractCarriageChainHandler {
    @Resource
    private CarriageService carriageService;

    @Override
    public CarriageEntity doHandler(WaybillDTO waybillDTO) {
        CarriageEntity carriageEntity = null;
        //寄快递地址id与收快递地址id一样说明是同城送
        if (ObjectUtil.equals(waybillDTO.getSenderCityId(), waybillDTO.getReceiverCityId())) {
            carriageEntity = carriageService.findByTemplateType(CarriageConstant.SAME_CITY);
        }
        return doNextHandler(waybillDTO, carriageEntity);
    }
}

```



```java
/**
 * 省内寄
 *
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 14:52
 */
@Order(200)
@Component
public class SameProvinceChainHandler extends AbstractCarriageChainHandler {
    @Resource
    private CarriageService carriageService;

    @Resource
    private AreaFeign areaFeign;

    @Override
    public CarriageEntity doHandler(WaybillDTO waybillDTO) {
        CarriageEntity carriageEntity = null;
        //1.获取寄快递城市id的省份id，收快递城市id的省份id
        Long receiverProvinceId = areaFeign.get(waybillDTO.getReceiverCityId()).getParentId();
        Long senderProvinceId = areaFeign.get(waybillDTO.getSenderCityId()).getParentId();
        //2.判断两者省份id是否相同 如果相同则证明是同省
        if (ObjectUtil.equals(receiverProvinceId, senderProvinceId)) {
            //省内
            //3.根据类型查询模板表中数据
            carriageEntity = carriageService.findByTemplateType(CarriageConstant.SAME_PROVINCE);
        }
        //4.执行下一个链接的处理方法
        return doNextHandler(waybillDTO, carriageEntity);
    }
}

```

```java
/**
 * 经济区互寄
 *
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 15:05
 */
@Order(300)
@Component
public class EconomicZoneChainHandler extends AbstractCarriageChainHandler {

    @Resource
    private CarriageService carriageService;

    @Resource
    private AreaFeign areaFeign;

    @Override
    public CarriageEntity doHandler(WaybillDTO waybillDTO) {
        CarriageEntity carriageEntity = null;
        //1.获取寄快递城市id的省份id，收快递城市id的省份id
        Long receiverProvinceId = areaFeign.get(waybillDTO.getReceiverCityId()).getParentId();
        Long senderProvinceId = areaFeign.get(waybillDTO.getSenderCityId()).getParentId();
        //2.获取经济区城市配置枚举
        LinkedHashMap<String, EconomicRegionEnum> economicRegionMap = EnumUtil.getEnumMap(EconomicRegionEnum.class);
        //3.判断省份是否在经济区中
        EconomicRegionEnum economicRegionEnum=null;
        for (EconomicRegionEnum regionEnum : economicRegionMap.values()) {
            //该经济区是否全部包含收发件省id
            boolean result = ArrayUtil.containsAll(regionEnum.getValue(), receiverProvinceId, senderProvinceId);
            if (result){
                economicRegionEnum = regionEnum;
                break;
            }
        }
        if (ObjectUtil.isNotEmpty(economicRegionEnum)){
            //根据编码类型查询
            LambdaQueryWrapper<CarriageEntity> queryWrapper = Wrappers.lambdaQuery(CarriageEntity.class)
                    .eq(CarriageEntity::getTransportType,CarriageConstant.ECONOMIC_ZONE)
                    .eq(CarriageEntity::getTransportType,CarriageConstant.REGULAR_FAST)
                    .like(CarriageEntity::getAssociatedCity,economicRegionEnum.getCode());
            carriageEntity=this.carriageService.getOne(queryWrapper);
        }
        return doNextHandler(waybillDTO,carriageEntity);
    }
}

```



```java
/**
 * 跨省寄
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 15:19
 */
@Order(400)
@Component
public class TransProvinceChainHandler extends AbstractCarriageChainHandler {
    @Resource
    private CarriageService carriageService;

    @Override
    public CarriageEntity doHandler(WaybillDTO waybillDTO) {
        CarriageEntity carriageEntity =carriageService.findByTemplateType(CarriageConstant.TRANS_PROVINCE);
        return doNextHandler(waybillDTO,carriageEntity);
    }
}
```



查找运费模板处理链 @Order注解

```java
/**
 * 查找运费模板处理链 @Order注解
 *
 * @author <a href="https://github.com/Dazhou-del">Dazhou</a>
 * @create 2024-03-05 15:23
 */
@Component
public class CarriageChainHandler {

    /**
     * 按照spring的注入特性，按照@Order的顺序从小到大注入到集合中
     */
    @Resource
    private List<AbstractCarriageChainHandler> chainHandlers;

    private AbstractCarriageChainHandler firstHandler;

    /**
     * 组装处理链 将每个handler按顺序放到责任链中
     */
    @PostConstruct
    private void constructChain() {
        if (CollUtil.isEmpty(chainHandlers)) {
            throw new SLException("not found carriage chain handler!");
        }
        //处理链中第⼀个节点
        firstHandler = chainHandlers.get(0);
        for (int i = 0; i < chainHandlers.size(); i++) {
            if (i == chainHandlers.size()) {
                //最后一个节点
                chainHandlers.get(i).setNextHandler(null);
            } else {
                //设置下一个节点
                chainHandlers.get(i).setNextHandler(chainHandlers.get(i + 1));
            }
        }
    }
    public CarriageEntity findCarriage(WaybillDTO waybillDTO) {
        //从第⼀个节点开始处理
        return firstHandler.doHandler(waybillDTO);
    }

}

```



### 新学方法

>
>
>将枚举类 转换成一个map

```java
        LinkedHashMap<String, EconomicRegionEnum> economicRegionMap = EnumUtil.getEnumMap(EconomicRegionEnum.class);
```

>
>
>对象之间比较

```java
ObjectUtil.equals(waybillDTO.getSenderCityId(), waybillDTO.getReceiverCityId())
```

>
>
>看ids 是否包含在数组中 参数1数组,参数2 3 4 那些id

```java
boolean result = ArrayUtil.containsAll(regionEnum.getValue(), receiverProvinceId, senderProvinceId);
```

>
>
>@PostConstruct注解 

@[PostConstruct](https://so.csdn.net/so/search?q=PostConstruct&spm=1001.2101.3001.7020)是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。



## 集成支付宝

### 支付流程

![](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/1660360908435-85b5b255-307b-4704-8126-94670d817327.jpeg)



流程说明：

- 用户下单成功后，系统会为其分配快递员
- 快递员根据取件任务进行上门取件，与用户确认物品信息、重量、体积、运费等内容，确认无误后，取件成功
- 快递员会询问用户，是支付宝还是微信付款，根据用户的选择，展现支付二维码
- 用户使用手机，打开支付宝或微信进行扫描操作，用户进行付款操作，最终会有支付成功或失败情况
- 后续的逻辑暂时不考虑，支付微服务只考虑支付部分的逻辑即可

支付顺序图

![](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/050a0c2e7f32582b466f0ccd303ae2f0.svg)

### 加密算法

​	加密算法分为可逆性和不可逆的

可逆分为：对称性加密和非对称性加密，对称性加密就是使用同一个密钥对数据进行加密解密。非对称算法的密钥对包含公钥和私钥，其中私钥由密钥属主保管，且不能泄露，公钥可以通过明文的方式分发给其它人。通过私钥加密的数据只能由公钥解密，通过公钥加密的数据只能由私钥解密，由于加密和解密使用不同的密钥，因此称为非对称加密。以下是一个非对称加密算法应用示例：

![img](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/v2-4eafed8065766a0224551a25182ce4f5_r.jpg)

不可逆常见算法:MD5、sha1、sha256

对称性常见算法:DES、3DES、AES

非对称性常见算法包括：RSA、ECC

支付宝中使用到的加密：

![支付宝支付流程分析](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/1540b47412114c689ff7e819a2605e6c.png)



### 通用版集成

1. 打开支付宝开放平台 https://open.alipay.com/ 登录
2. 打开控制台

![image-20231212224401578](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20231212224401578.png)3.点击沙箱

![image-20231212224435632](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20231212224435632.png)

4.查看沙箱应用，这些都需要写到配置文件中

![image-20231212224549681](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20231212224549681.png)



![image-20231212224651348](https://tptptptpt.oss-cn-guangzhou.aliyuncs.com/picture/image-20231212224651348.png)
